# Chapter 02 정리  

2-1 UserDaoTest 다시보기
----------------------------------------------------------------------------

테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서 만든 코드를 확신할 수 있게 해주는 작업이다.

기존 테스트코드의 특징
 * main 메소드를 이용해 쉽게 테스트 수행 가능
 * 테스트할 대상인 UserDao를 직접 호출해서 사용함
 * 테스트에 사용할 값을 직접 코드에서 만들어 줌
 * 테스트 결과를 콘솔을 통해 확인함
 
 웹을 통한 DAO 테스트 방법의 문제점
 * 서비스 계층, MVC 프리젠테이션 계층 등등을 테스트 결과가 확인가능하게 대충이라도 만들어야 함
 * 테스트 실행과정이 너무 번거로움
 * 에러가 발생했을때 테스트하고자 한 코드에서 문제가 발생했는지, 다른 코드에서 문제가 발생했는지 확인하기 번거로움
 
 => 테스트하고 싶었던 건 UserDao였는데 다른 계층의 코드와 컴포넌트 서버의 설정 상태 까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트하는 것은 번거롭고, 오류가 있을때도 빠르게 대응하기 어려움
 
 테스트하고자 하는 대상이 명학하다면 그 대상에만 집중해서 테스트하는 것이 바람직하다. 한꺼번에 너무 많은것을 몰아서 테스트하면 테스트 수행과정도 복잡해지고, 오류가 발생했을 때 정확한 원인을 찾기가 힘들다.
 
 => 테스트는 가능한 작은 단위로 쪼개서 집중 할 수 있어야 한다.
 
 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(Unit Test)라고 한다. 여기서 말하는 단위는 정확한 기준이 없다. 다만, 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위를 단위라고 본다.
 
 UserDaoTest의 특징으로 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 역시 코드를 통해 자동으로 실행한다는 것이 있었는데, 테스트 값을 직접입력 해야하거나 수동으로 테스트를 수행해야한다면 테스트 수행이 부담이 될 수 있다.
 즉, 테스트는 자동으로 수행되도록 코드로 만들어 두는 것이 중요하고, 복잡성을 줄이기 위해 어플리케이션을 구성하는 클래스 안에 테스트코드를 포함시키기 보다는 별도로 테스트용 클래스를 만들어 운용하는 것이 좋다.
 
 테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐만 아니라, 기존에 만들어두었던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 정상동작하는지 확인할 수 있기 때문에 지속적인 개선과 점진적인 개발을 위해서 필요하다.
 
 UserDaoTest의 문제점
  * 테스트 결과가 콘솔로 출력되고 이를 확인하는 것은 사람이 직접 해야한다.
  * main 메소드를 매번 실행해야 하고 DAO가 여러개가 되면 테스트를 위해 매 DAO마다 main을 하나씩 실행해야 한다.
  
  2-2 UserDaoTest 개선
  ----------------------------------------------------------------------------
  
  테스트 검증의 자동화
  
  테스트 결과는 성공/실패로 나눌 수 있고, 실패의 경우는 에러가 발생해서 실패/결과가 다르게 나와 실패로 나눌 수 있다.
  에러가 발생해서 실패한 경우는 에러메세지와 호출스택이 출력될 것이기 때문에 성공/결과가 다르게 나와 실패를 조건문으로 구분한다.
  
  => 값을 하나하나 확인할 필요 없이 "테스트 성공" 이라는 메세지가 출력되는지만 확인하면 되게 수정
  
  테스트의 효율적인 수행과 결과 관리
  
  main 메소드를 이용한 테스트 방법만으로는 어플리케이션 규모가 커지고 테스트 개수가 많아지면 테스트를 수행하는 일이 점점 부담이 될 것이다.
  
  => JUnit 이라는 프레임워크를 사용하자. 
 
 기존에 만들었던 main 메소드 테스트는 제어의 흐름을 가지고 있기 때문에 프레임워크에 적용하기에 적합하지 않다. 테스트가 main 메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이기 때문이다.
 JUnit 프레임워크가 요구하는 두가지 조건에 맞추어 main 메소드를 활용한 테스트코드를 옮기자. 두가지 조건은 @Test 어노테이션을 적용할 것과 public 접근자를 가질것 이다.
 
 테스트 결과를 검증하는 조건문(if/else if/else)을 JUnit이 제공해주는 assetThat이라는 스태틱 메소드로 변경한다.
 
 마지막으로 main 메소드에 JUnitCore 클래스의 main메소드를 호출해주는 코드를 넣어주면 실행된다.
 => JUintCore.main("패키지명.UserDaoTest");
 
   2-3 개발자를 위한 테스팅 프레임 워크 JUnit
   ----------------------------------------------------------------------------
   
   Junit 은 사실상 자바의 표준 테스팅 프레임 워크
   
   Junit 테스트 실행 방법? => IDE에 내장된 JUnit 테스트 지원 도구를 사용한다. => 테스트를 실행하고 테스트 결과(총 수행시간, 수행한 테스트 케이스의 수, 성공/실패 케이스의 수)를 보기좋게 정리해준다.
   
   JUnit 테스트의 실행과 그 결과를 확인하는 방법이 매우 간단하고 직관적이며 소스와 긴밀하게 연동해서 결과를 볼 수 있기 때문에, 개발 중에 테스트를 실행하고자 할 때 IDE의 지원을 받는 것이 가장 편리하다.
   
   반복적으로 테스트를 수행했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수 없다.
   
   단위 테스트는 코드가 바뀌지 않는다면 매번 실행할 때마다 동일한 테스트 결과를 얻을 수 있어야 한다. (DB의 데이터와 같은 외부 환경 뿐만 아니라 단위 테스트의 실행 순서에도 영향을 받지 않아야 한다.)
   
   @Test 어노테이션의 exepected 엘리먼트에 발생하리라 기대하는 예외 클래스를 지정하면 예상한 예외 발생없이 해당 테스트케이스를 마치면 테스트가 실패하고, 예상한 예외가 던져지면 테스트가 성공한다.
   
   평소에는 정상적으로 동작하는 것 처럼 보이지만 특별한 상황이 되면 엉뚱하게 동작하논 코드를 만들었는데 테스트를 안 해봤다면 나중에 문제가 발생헀을때 원인을 찾기 힘들다.
   
   개발자들이 곧잘 하는 실수가 테스트케이스를 만들때 성공하는 테스트케이스만 골라서 만든다는 것 => 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관들 들이는게 좋다.
   
   
   "TDD(Test Driven Development)" : 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법
   
   => 실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는 것이 TDD의 원칙 => 이 원칙을 항상 따르면 모든 코드는 빠짐없이 테스트로 검증된 것이다.
   
   TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만들기 때문에 테스트를 빼먹지 않고 만들 수 있다는 장점이 있다. 
   
   TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 짧게 가져가도록 권장한다. => 개발한 코드의 오류는 빨리 발견할 수록 대응이 쉽게 때문 => 테스트 없이 한번에 너무 많은 코드를 만드는것은 좋지 않다.
   
   JUnit이 테스트 클래스를 가져와 테스트를 수행하는 방식
   1. 테스트 클래스에서 @Test public void 메소드명() 형태의 테스트 메소드를 모두 찾는다.
   2. 테스트 클래스의 오브젝트를 하나 만든다.
   3. @Before가 붙은 메소드가 있으면 실행한다.
   4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장한다
   5. @After가 붙은 메소드가 있으면 실행한다.
   6. 2~5 반복
   7. 결과 종합하여 반환
   
   => @Before에서 @Test의 공통적인 준비작업, @After에서 @Test의 공통적인 정리작업을 수행해주면 좋다.
   
   주의사항! 각 테스트 메소드를 실행할 때 마다 테스트 클래스의 오브젝트를 새로 만든다 (한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다.)
   => 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만든다.
   
   "픽스쳐(fixture)" : 테스트를 수행하는데 필요한 정보나 오브젝트
   
   2-4 스프링 테스트 적용
   ----------------------------------------------------------------------------
   
   테스트를 위한 어플리케이션 컨텍스트 관리
   
   @Before 메소드가 테스트 메소드 개수만큼 바복되기 떄문에 어플리케이션 컨텍스트 생성에 많은 시간이 걸릴 수 있다.
   또한, 테스트는 가능한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙이다. 하지만, 어플리케이션 컨텍스트처럼 생서에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다.
   
   => 스태틱 필드에 애플리케이션 컨텍스트를 저장해 두자 (JUnit 4버전 이하의 @BeforeClass 어노테이션 이용하여 스태틱 메소드를 통해 스태틱 필드에 초기화 하고 공유하여 사용하자!)
   
   => @RunWith(SpringJUnit4ClassRunner.class) => JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 어노테이션이다.SpringJUnit4ClassRunner 확장 클래스를 지정해주면 테스트를 진행하는 중에 사용할 어플리케이션 컨텍스트를 만들고 관리하는 작업을 해준다.
   => @ContextConfiguration은 자동으로 만들어줄 어플리케이션 컨텍스트의 설정파일 위치를 지정한 것이다.
   
   스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 어플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 어플리케이션 컨텍스트를 테스트 오브젝트의 특정 필드에 주입해준다.
   이는, 여러개의 테스트 클래스에서 같은 설정파일의 어플리케이션 컨텍스트를 사용한다면 이를 클래스 사이에도 공유하게 해준다.
   
   @Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.
   
   의문) 2-17 코드에서는 applicationContext.xml에 정의된 Bean이 아닌 ApplicationContext라는 타입의 변수에 @Autowired를 붙였는데 DI가 되었다?
   
   => 스프링 어플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록하기 때문에 ApplicationContext에는 ApplicationContext 타입의 빈이 존재하는 셈이기 때문에 DI가 된다.
   
   @Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾아 주입해준다. 만약 같은 타입의 빈이 두개이상 있는 경우에는 변수의 이름과 같은 이름의 빈에 주입 해준다 (없으면 예외)
   
   
   DI와 테스트
   
   DI를 통해 오브젝트를 주입하지 않는 환경에서도 DI를 사용해야하나?
   
   => DI를 사용해야한다
   1. 소프트웨어 개발에서 절대로 바뀌지 않는것은 없다. 당장에 클래스를 바꿔서 사용할 일이 없어도 인터페이스와 DI를 사용하는 것은 나중에 변경이 발생할 때 수정에 필요한 시간과 비용을 절약해준다.
   2. 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해주면 AOP를 통해 추가 기능을 쉽게 구현할 수 있다.
   3. 효율적인 테스트를 손쉽게 만들기 용이하다. 
   
   테스트에 DI를 이용하는 방법
   
   1. 테스트 코드에 의한 DI
   DI는 어플리케이션 컨텍스트 같은 스프링 컨테이너에서만 할 수 있는 작업이 아니다. 테스트 코드 내에서 setter를 호출해서 직접 DI 할 수 도 있다.
   어플리케이션 컨텍스트에서 가져온 의존관계를 강제로 변경하는 방법이고, 나머지 모든 테스트를 수행하는 동안 변경된 어플리케이션 컨텍스트가 계속 사용될 것이기 때문에
   @DirtiesContest라는 어노테이션을 추가하여 이 어노테이션이 적용된 스프링 테스트 컨텍스트 프레임워크에 해당 클래스의 테스트에서 어플리케이션 컨텍스트의 상태를 변경한다는 것을 알려주고, 다른 테스트 클래스에는 이 어플리케이션 컨텍스트를 공유하지 않게 방지해준다.
   
  2. 테스트를 위한 별도의 DI 설정
  별도의 applicationContext.xml 파일을 구성하고 테스트 클레스의 @ContextConfiguaration 어노테이션의 location 값을 새로만든 테스트용 설정파일을 적용해준다.
  설정파일을 하나 더 작성하고 테스트에 맞게 수정해주는 수고만으로도 테스트에 적합한 오브젝트의 의존관계를 만들어 사용할 수 있다.
  
  3. 컨테이너 없는 DI 테스트
  스프링 컨테이너를 사용하지 않고 테스트를 만드는 방법이다. 즉, 수동 DI만을 이용해 테스트코드를 작성한다.
  테스트를 위한 DataSource를 직접 만드는 번거로움은 있지만 어플리케이션 컨텍스트를 아예 사용하지 않으니 코드가 단순해지고 이해하기 쉽다.
  이것이 가능한 이유는 DI를 적용했기 때문이다. DI는 객체지행 프로그래밍 스타일이다 따라서 DI를 위해 컨테이너가 반드시 필요한 것은 아니다. DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아니다.
  
  
   2-5 학습 테스트로 배우는 스프링
   ----------------------------------------------------------------------------  
   
   학습테스트 : 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히기 위한 목적으로 작성하는 테스트(기능에 대한 검증 목적이 아님)
   
   학습테스트를 통해 빠르고 정확하게 테스트 대상의 사용법을 익힐 수 있다.
   
   장점
   1. 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다. => 학습 테스트는 코드로 예제를 만드는 것에 비해 자동화된 테스트 코드로 다양한 조건이나 값에 따라 기능이 어떻게 동작하는지 쉽게 확인할 수 있다.
   2. 학습 테스트 코드를 개발 중에 참고할 수 있다. => 수동으로 예제를 만드는 방법은 코드를 계속 수정해가면서 기능을 확인해보다 최중 수정한 예제만 남게되지만, 학습 테스트는 다양한 기능과 조건에 대한 테스트코드를 개별적으로 만들고 남겨둘 수 있다.
   3. 프레임워크나 제품을 업그레이드 할 때 호환성 검증을 도와준다 => 기존에 사용했던 API나 기능에 변화가 있거나 업데이트 된 제품에 버그가 있다면 학습테스트를 통해 미리 확인할 수 있다.
   4. 테스트 작성에 대한 좋은 훈련이 된다 => 학습 테스트는 한 두가지 간단한 기능에만 초점을 맞추면 되기 때문에 어플리케이션 개발 중에 작성하는 테스트보다는 한결 작성하기도 수월하고 부담도 작다.
   
   예제
   1. JUnitTest Object 테스트
   2. Spring test context 테스트
   
   버그 테스트 : 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트, 버그 테스트는 해당 버그가 원인이 되어 실패하도록 만들고 버그테스트가 성공할 수 있도록 어플리케이션 코드를 수정하여 테스트가 성공하게 해야한다.
   
   장점
   1. 테스트의 완성도를 높혀준다 => 기존 테스트에서 검증하지 못했던 부분을 보완해주고, 테스트 케이스로 만들어두면 문제가 다시 등장하더라도 쉽게 추적이 가능하다.
   2. 버그의 내용을 명확하게 분석하게 해준다. => 버그가 있을 때 테스트로 만들어서 실패하게 하려면 어떤 이유 떄문에 문제가 생겼는지 명확히 알아야 한다.
   3. 기술적인 문제를 해결하는데 도움이 된다. => 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 문제를 해결하는데 도움이 되고, 외부에 이슈를 공유하기에도 좋다.
   
   2-6 정리
   ----------------------------------------------------------------------------  
   * 테스트는 자동화 되어야 하고, 빠르게 실행할 수 있어야 한다.
   * main() 테스트 대신 JUnit 프레임워크를 이요한 테스트 작성이 편리하다.
   * 테스트 결과는 일관성이 있어야한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안된다.
   * 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않은 테스트는 없는 것보다 나쁠 수 있다.
   * 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
   * 테스트하기 쉬운 코드가 좋은 코드다.
   * 테스트르르 먼저 만들고 테스트를 성공시키는 코들르 만들어가는 테스트 주도 개발방법도 있다.
   * 테스트 코드도 어플리케이션 코드처럼 적절한 리팩토링이 필요하다.
   * @Before, @After를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
   * 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
   * 동일한 설정파일을 사용하는 테스트는 하나의 어플리케이션 컨텍스트를 공유한다.
   * @Autowired를 통해 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
   * 기술의 사용 방법을 익히고 이해를 돕기 위해 학습테스트를 작성하는 것이 권장된다.
   * 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.