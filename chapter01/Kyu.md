
# Chapter 01 정리  

1-1 초난감 DAO
----------------------------------------------------------------------------
UserDao code : DB connect, sql statement, query 실행, query 실행결과 반환,  DB disconnect(자원정리), 예외처리 코드, 테스트코드 모두 포함
=> 데이터 등록, 조회 정상적으로 수행 됨

1-2 DAO 분리
---------------------------------------------------------------------------
1-1의 UserDao 코드가 정상적으로 동작하지만 분리와 확장을 고려한 설계가 아니다.
* 관심이 같은 것 끼리는 하나의 객체 또는 친한 객체(상속관계, 포함관계등)로 모이게 하고, 관심이 다른 것들은 가능한 다 따로 떨어져서 서로 영향을 주지 않도록 분리해야한다. (Separation of Concerns)
* 결합도는 낮추고, 응집도는 높히는 작업

1-1의 UserDao코드에 묶여있는 여러가지 관심사항
1. DB connection
2. sql statement
3. DB disconnection

* 먼저 DB connection을 extract method를 통해 refactoring 하자.
* UserDao 코드에 DB connection 얻어오는 부분을 getConnection 메소드로 추출
=> 관심에 따라 코드를 분리해 놓았기 때문에 한가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다.

UserDao 코드를 다른 사용자에게 제공하지 않으면서 getConnection 메소드만 수정하게 할 수 없을까?
* UserDao를 getConnection abstract 메소드를 가지는 abstract class로 만들고, 이를 상속하는 NUserDao, DUserDao류의 class를 만들어 사용한다.

**슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상메소드나 오버라이딩 가능한 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 template method pattern 이라고 한다.**
 (변하지 않는 기능은 슈퍼클래스에, 자주 변경되어 확장할 기능은 서브클래스에 만든다. 슈퍼클래스에서 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해 두고, 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다. 슈퍼클래스에서 디폴트 기능을 정의해두거나 비웠다가 서브클래스에서 선택적으로 오버라이드 할 수 있도록 만들어둔 메소드를 hock method 라고 한다.)
**서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 방법을 factory method pattern 이라고 한다.**
(서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.)
=> 68p 그림1-2가 위 두 패턴이 적용된 클래스 다이어그램을 보여주고 있다.

cf) 디자인 패턴
디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션, 패턴의 설계 구조를 보면 대부분 비슷한데, 그 이유는 객체지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 클래스 상속, 오브젝트 합성 이라는 두가지 구조로 정리되기 때문이다. 패턴에서 핵심은 패턴의 목적 또는 의도이다. 패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지 기억해둬야 한다.

1-2 DAO 분리 하였지만 남아있는 문제점?
=> 상속관계는 여전히 두 가지 다른 관심사에 대해 긴밀한 결합을 허용한다
ex) 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있음, 클래스는 이중상속을 허용하지 않기 때문에 추후 다른목적으로 UserDao에 상속 적용하기 어렵다.

1-3 DAO의 확장
---------------------------------------------------------------------------
추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서다. **그러나 단점이 많은 상속이라는 방법을 사용했다**
=> DB connection 과 관련된 부분을 서브클래스가 아니라 아예 별도의 클래스에 담고, 이렇게 만든 클래스를 UserDao가 사용하게 한다.

코드로 보면 아래와 같은 형태이다.

public class UserDao {
	private SimpleConnectionMaker simpleConnectionMaker;
	public UserDao() {
	this.simpleConnectionMaker = new SimpleConnectionMaker ();
}

public void add(User user) throws ClassNotFoundException, SQLExcepion {
	Connection c = simpleConnectionMaker.makeNewConnection();
	...
}

public void get(String id) throws ClassNotFoundException, SQLExcepion {
	Connection c = simpleConnectionMaker.makeNewConnection();
}

}

public class SimpleConnectionMaker {
public Connection makeNewConnection() throwsClassNotFoundException, SQLExcepion {
...
}
}

문제점?
1. UserDao가 simpleConnectionMaker의 makeNewConnection이라는 메소드에 디팬던시가 걸려있다.
2. DB커넥션을 제공하는 클래스가 구체적으로 어떤 클레스인지 UserDao가 알고 있는 구조이다.

=> 인터페이스를 적용하여 구현 클래스에 대한 구체적인 정보를 감추자!
=> 오브젝트 생성과정에서 구현 클래스를 선택해야겠지만, 이외의 부분은 인터페이스로 추상화 해놓은 최소한의 통로를 통해 접근하는 쪽에서는 어떤 클래스를 사용할지 몰라도 된다.

문제점
1. UserDao의 다른 모든 곳에서는 인터페이스를 통해 사용하게 만들어서 DB connection을 제공하는 클래스에 대한 구체적인 정보를 제거 가능하지만, 초기에 오브젝트를 생성하는 과정에서 생성자 코드는 제거되지 않고 남아있다.

=> UserDao 오브젝트가 다른 오젝트와 관계를 맺으려면 관계를 맺을 오브젝트가 있어야 하는데, 이 오브젝트를 UserDao 코드내에서 만들지 말고 메소드 파라미터를 이용해서 외부에서 잔달받자! 즉, **클래스 사이에서 관계를 만들지 말고 오브젝트 사이에서 관계를 만들자**  런타임에 오브젝트 관계를 갖는 구조로 만들어주는것이 클라이언트 코드(여기서는 UserDaoTest)의 책임이다.
(클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나면서 만들어지지만, 오브젝트 사이의 관계는 그렇지 않다.)

객체지향 원칙
* Open-Closed Principle: 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
* High coherence: 응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변화는 부분이 크다는 것을 의미한다.
* Low coupling: 하나의 오브젝트가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 유지하는 정도를 의미한다. (책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다. 느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 독립적이고 알 필요도 없게 만들어 준다.)
* 이외에도 SOLID라 불리는 Single-Responsibility Principle, Open-Closed Principle,Liskov-Substitution Principle, Interface-Segregation Principle, Dependency Inversion Principle 등이 있다.

패턴
* strategy pattern: 자식의 context에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스 등을 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용하는 디자인 패턴
ex) UserDao를 사용하는 UserDaoTest는 UserDao가 사용할 전략인 ConnectionMaker를 UserDao의 생성자 또는 setter를 통해 제공해준다.
* factory method pattern: 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 디자인 패턴
* template method pattern: 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상메소드나 오버라이딩 가능한 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 패턴

=> **스프링이란 이런 객체지향 설계원칙과 디자인 패턴에 나타난 장점을 개발자들이 자연스럽게 활용할 수 있도록 도와주는 프레임워크**

1-4 제어의 역전(IoC)
---------------------------------------------------------------------------

factory: 객체의 생성 방법을 결정하고 만들어진 오브젝트를 반환해주는 오브젝트 (디자인 패턴 중 하나인 factory method pattern과 다른 용어, 단순히 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽으로 역할과 책임을 분리하는 목적으로 사용하는 것이  factory이다.)

그림 1-8을 보면 factory를 사용함으로서 어플리케이션 컴포넌트 역할을 하는 오브젝트와 어플리케이션 구조를 결정하는 오브젝트를 분리하였다는 것을 확인할 수 있다.

일반적인 프로그램 흐름은 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 오브젝트를 만들지 결정한다. 즉 모든 종류의 작업을 사용하는 쪽에서 제어한다. **제어의 역전이란 이런 제어의 흐름을 뒤집어 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않고 생성하지도 않는다. 오브젝트 자신 역시 어디서 생성되고 사용되는지 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임한다.** 

라이브러리는 사용하는 쪽에서 어플리케이션 흐름을 직접 제어하지만, 프레임워크는 어플리케이션 코드가 프레임워크에 의해 사용된다.

1-5 스프링의 IoC
---------------------------------------------------------------------------

스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(Bean) 이라고 부른다. 즉 스프링빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 IoC가 적용된 오브젝트를 가르키는 말이다.

스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(bean factory)라고 부른다. 빈 팩토리를 조금 더 확장한 어플리케이션 컨텍스트라는 것이 있는데, 어플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리다.
빈 팩토리와 어플리케이션 컨텍스트는 거의 동일한 개념이고, 빈 팩토리라고 부를떄는 IoC의 기본 기능(빈의 생성과 관계설정)에 초점을 맞춘것이고, 어플리케이션 콘텍스트라고 부를때는 모든 구성요소의 제어작업을 담당하는 IoC 엔진으로서의 기능에 초점을 맞춘 것이다.

어플리케이션 콘텍스트는 설정정보(여기서는 DaoFactory)를 가져와 빈의 생성, 관계설정 등의 제어작업을 총괄하는 IoC 컨테이너이다.

DaoFactory를 어플리케이션 콘텍스트에서 사용하기 위한 설정정보로 만들기 위해서 @Configuration 어노테이션을 달아 어플리케이션 콘텍스트가 사용할 설정정보 클래스라고 명시한다.
그리고, 오브젝트를 반환하는 메소드(userDao, connectionMaker)에 @Bean 어노테이션을 달아 오브젝트 생성을 담당하는 IoC용 메소드라고 명시한다.

@Configuration 어노테이션이 붙은 자바 코드를 설정정보로 사용하기 위해 ApplicationConfigurationContext를 이용하여 다음과 같이 어플리케이션 콘텍스트를 생성한다.
ApplicationContext context = new ApplicationConfigurationContext(DaoFactory.class);

getBean메소드는 ApplicationConetext가 관리하는 오브젝트를 요청하는 메소드이다. 첫번째 파라미터는 ApplicationConetext에 등록된 빈 이름(설정클래스의 메소드 이름이 빈의 이름이 된다), 두번째 파라미터는 빈의 클래스 타입이다.
특정 클래스를 생성하는 방식이나 구성을 다르게 하는 메소드를 추가하면 메소드 이름을 다르게하여 새로운 빈 이름으로 빈을 만들고 이를 주입해서 사용하면 된다.

오브젝트 팩토리를 이용하여 IoC적용한 방식 / 스프링 어플리케이션 컨텍스트를 이용하여 IoC적용한 방식의 차이점
 * 오브젝트 팩토리를 이용하여 IoC적용한 방식: 코드에서 명시한 제한적인 역할을 함, 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 있음,
 * 스프링 어플리케이션 컨텍스트를 이용하여 IoC적용한 방식: IoC를 적용해서 관리한 모든 오브젝트에 대한 생성과 관계설정을 담당함, 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고 생성정보와 연관관계 정보를 별도의 설정정보를 통해 얻음

어플리케이션 컨텍스트를 이용했을때의 장점
 * 클라이언트틑 구체적인 팩트리 클래스를 알 필요가 없다: 오브젝트 팩토리를 이용하면 클라이언트가 필요한 오브젝트를 가져오려면 어떤 팩트리 클래스를 사용하는지 알아야하고, 필요할때마다 팩토리 오브젝트를 생성해야 하지만 어플리케이션 컨텍스트를 이용하면 오브젝트 팩토리가 아무리 많아져도 이를 알거나 직접사용할 필요 없이 일관된 방식(자바코드 또는 xml코드로 된 설정정보에서 얻어오는 방식)을 통해 원하는 오브젝트를 가져올 수 있다.
 * 종합 IoC 서비스를 제공해준다: 오브젝트 생성과 다른 오브젝트와의 관계설정 뿐만 아니라 오브젝트가 만들어지는 방식, 시점, 자동생성, 후처리, 조합, 설정 방식 다변화, 인터셉팅 등등.. 오브젝트를 효과적으로 사용할 다양한 기능을 제공한다
 * 빈을 검색하는 다양한 방법을 제공해준다: getBean 메소드는 빈을 타입만으로 검색하거나 특정 어노테이션 설정이 되어있는 빈을 찾아주기도 한다.

용어정리
 * 빈(bean): 스프링이 IoC 방식으로 관리하는 오브젝트 (스프링이 사용하는 모든 오브젝트가 다 빈은 아니고, 직접 생성과 제어를 담당하는 오브젝트만을 빈이라고 한다)
 * 빈 팩토리(bean factory): 스프링 IoC를 담당하는 컨테이너 빈을 생성, 등록, 조회, 관리 하는 기능을 담당한다. (보통은 빈 팩토리를 바로 사용하지 않고 이를 확장한 어플리케이션 컨텍스트를 이용한다)
 * 어플리케이션 컨텍스트(application context): 빈 팩토리를 확장한 Ioc 컨테이너 빈을 생성, 등록, 조회, 관리 하는 기본기능은 빈 팩토리와 동일하지만 스프링이 제공하는 각종 부가서비스를 추가로 제공
 * 설정정보(configuration metadata): 어플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 설정정보
 * 컨테이너(container): IoC방식으로 빈을 관리한다는 의미에서 어플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너 라고 한다.
 * 스프링 프레임워크(spring framework): IoC 컨테이너, 어플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 뜻함

 1-6 싱글톤 레제스트리와 오브젝트 스코프
 ---------------------------------------------------------------------------

* 오브젝트 팩토리(DaoFactory)를 이용하여 userDao를 2번이상 생성시 생성 떄 마다 다른 오브젝트를 반환한다.

* 스프링 어플리케이션 컨텍스트(ApplicationContext)를 이용하여 userDao를 2번이상 생성시 생성 떄 마다 같은 오브젝트를 반환단다.

=> 어플리테이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.

=> 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문에 아무리 자바 오브젝트 생성과 GC성능이 좋아도 한들 매번 새로운 오브젝트를 생성하고 GC로 정리하는 작업을 하면 서버가 감당하기 어려운 부하가 걸린다.



싱글톤 패턴(Singleton Pattern)

싱글톤 패턴은 어떤 클래스를 어플리케이션 내에서 제한된 인스턴스 개수(주로 하나)만 존재 하도록 강제하는 패턴이다. 제한된 개수의 오브젝트는 어플리케이션 내에서 전역적으로 접근이 가능하다. 오브젝트 수를 제한해야하고, 이를 어플리케이션 전반에 공유하여 사용해야하는 경우에 사용된다.



자바에서 싱글톤 패턴 구현방법

* 클래스 밖에서 오브젝트를 생성하지 못하도록 생성자를 private으로 설정한다.
* 생성된 싱글톤 오브젝트를 저장할 수있는 자신과 같은 타입의 private static 필드를 정의한다.
* Static factory method인 getInstance를 만들고, 이 메소드가 최초로 호출되는 시점에만 생성자를 호출해서 오브젝트를 생성시킨다. 생성된 오브젝트는 private static 필드에 저장된다. (또는  private ststic 필드의 초기값으로 오브젝트를 미리 만들어둬도 된다.)
* 오브젝트가 생성된 이후에는 getInstance 메소드를 통해 만들어져 있는  private static 필드에 저장해둔 오브젝트를 반환받아 사용한다.



싱글톤 패턴의 한계

* private 생성자를 가지고 있기 떄문에 상속할 수 없다. (private static 필드와 메소드역시 다형성 같은 객체지향 특징이 적용되지 않기 때문에 상속하기 어렵다.)
* 테스트하기 어렵다.
* 서버환경에 따라 싱글톤이 하나만 만들어지는 것을 보장하기 어렵다. 
* 싱글톤의 사용은 전약 상태를 만들 수 있기 때문에 바람직하지 못하다.



싱글톤 레지스트리

싱글톤 레지스트리: 스프링이 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공하는 것으로, 스프링 컨테이너는 싱글톤을 생성, 관리, 공급하는 싱글톤 관리 컨터이너이기도 하다. (스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는것을 지지하지만, 자바의 싱글톤 패턴 구현방법은 앞서 서술한 여러가지 단점이 있기 때문에 스프링 컨테이너가 직접 싱글톤 형태의 오브젝트를 관리한다)

싱글톤 레즈스트리의 장점: 스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 **평범한 자바 클래스를 싱글톤으로 활용**할 수 있게 해준다. 평범한 자바 클래스라도 IoC방식의 컨테이너를 사용해서 제어권을 컨테이너에게 넘기면 오브젝트 생성에 대한 모든 권한은 IoC기능을 제공하는 어플리케이션 컨텍스트에 있기 때문에 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다. 

스프링의 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 클래스도 public 생성자를 가질 수 있고, 간단히 오브젝트를 생성할 수 있고(테스트에 사용될 오브젝트를 간단히 생성할 수 있고), 싱글톤 패턴과 달리 **객체지향적인 설계 방식과 원칙, 디자인 패턴등을 적용하는데 제약이 없다.**



오브젝트가 싱글톤으로 만들어지기 때문에 주의해야할 사항

* 상태관리

  기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태적보를 내부에 갖고 있지 않은 statless(무상태) 방식으로 만들어져야 한다. 여러 스레드들이 동시에 싱글톤 오브젝트 인스턴스의 변수를 수정하는 것은 위험하다(racec condition). 

* 스프링 빈의 스코프

  스프링이 관리하는 오브젝트(스프링 빈)가 생성되고, 존재하고, 적용되는 범위를 스코프(scope)라고 한다. 스프링 빈의 스코프는 싱글톤이기 때문에 스프링 컨테이너 내에 한개의 오브젝트만 만들어져서 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 한 유지된다. 경우에 따라서 싱글톤 외의 스코프를 가질 수 있다.

 1-7 의존관계 주입(DI)
 ---------------------------------------------------------------------------

스프링 IoC 기능의 대표적인 동작원리는 주로 DI(의존관계 주입) 이다.

DI는 오브젝트 레퍼런스를 외부로 부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심이다.

의존관계에는 방향성이 있다. 예를들어 A가 B에 의존한다 라고 하면 B의변화는 A에게 영향을 미치지만, A의 변화는 B에게 영향을 미치지 않는다.

인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다.(결합도가 낮은 상태가 된다.) 의존관계란 한쪽의 변화가 다른쪽에 영향을 주는 것이라고 했으니, 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워질 수 있다.

모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계가 아닌 런타임시에 오브젝트 사이에 만들어지는 의존관계도 있다.

의존관계 주입은 구체적인 의존 오브젝트와 그것을 사용할 주체(보통 클라이언트라고 부르는 오브젝트)를 런타임시에 연결해주는 작업을 말한다.



의존관계 주입이란 아래의 3가지 조건을 충족하는 작업을 의미한다.

* 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. (인터페이스에만 의존하고 있어야 한다)
* 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
* 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어진다.

DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어맞는다.



스프링이 제공하는 IoC방식에는 DI 뿐만 아니라 의존관계 검색(Dependency Lookup)이라는 것도 있다.

코드에서는 구체적인 클래스에 의존하지 않고, 런타임 시에 의존관계를 결정한다는 점에서 의존관계 주입과 비슷하지만, 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 의존관계 검색이라고 불린다.

의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때에는 **메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 것**이다.

의존관계 검색은 의존관계 주입의 거의 모든 장점을 가지고있다. 단지 방법만 조금 다를 뿐이다. 하지만 의존관계 검색 방법은 코드안에 오브젝트 팩토리 클래스나 스프링 API가 나타나기 때문에 의존관계 주입 방법에 비해서 코드가 복잡해진다. 따라서 대게는 의존관계 주입 방법을 활용한다.

하지만, 의존관계 검색을 사용해야 할 때가 있는데, 스태틱 메소드 main을 사용 하는 경우에는 DI를 이용해 오브젝트를 주입방을 방법이 없기 떄문에 의존관계 주입을 사용하곤 한다. 서버에서도 main과 같은 기동 메소드는 없지만 사용자의 요청을 받을때마다 서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용하려면 한번은 의존관계 검색 방식을 이용해 오브젝트를 가져와야한다 (하지만 이런 서블릿은 스프링이 미리 만들어서 제공하기 때문에 직접 구현할 필요는 없다.)

의존관계 검색 방식에서는 검색하는 오브젝트 자신이 스프링 빈일 필요가 없다. 반면에 **의존관계 주입에서는 주입받은 오브젝트도 반드시 스프링 컨테이너가 만드는 빈 오브젝트여야 한다.** DI를 원하는 오브젝트에 다른 오브젝트를 주입하려면 주입받는 오브젝트에 대한 생성과 초기화 권한을 컨테이너가 가지고 있어야하고, 그러려면 주입받는 오브젝트도 IoC 방식으로 컨테이너에서 생성되는 오브젝트 즉, 빈이어야 하기 떄문이다.

DI에서 말하는 주입은 다이나믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터퍼에스 타입의 파라미터를 통해 이루어져야 한다.


의존관계 주입의 응용

기능 구현의 교환 
ex) 개발환경과 운영환경에서 DI의 설정정보에 해당하는 DaoFactory만 다르게 만들어두면 나머지 코드에는 손대지 않고 개발환경과 운영환경에서 각각 다른 런타임 오브젝트에 의존관계를 갖게 해줘서 문제를 해결할 수 있다.

부가기능 추가 (관심사의 분리 SoC를 통해 얻어지는 응집
ex) UserDao -> DConnectionMaker(실기능을 담당할 클래스) => UserDao -> CountingConnectionMaker(부가기능을 구현할 클래스) -> DConnectionMaker(실기능을 담당할 클래스)처럼 의존관계를 변경하여 부가기능을 구현할 수 있다.


의존관계 주입 시 반드시 생성자를 사용해야 하는것은 아니다. 생성자가 아닌 일반 메소드를 사용할 수 있을 뿐만 아니라, 생성자를 사용하는 방법보다 더 자주 사용된다.
* setter를 이용한 주입 : setter 메소드는 외부로부터 제공받은 오브젝트 레퍼런스를 저장했다가 내부 메소드에서 사용하게 하는 DI 방식에서 활용하기 적당하다.
* 일반 메소드를 이용한 주입 : setter는 메소드명이 set으로 시작해야하고, 한번에 한개의 파라미터만 가질 수 있기 때문에 이런 제약이 싫다면 여러 파라미터를 갖는 일반 메소드를 DI용으로 사용할 수 있다. 

스프링은 전통적으로 메소드를 이용한 DI 방법 중에서 setter를 이용한 방법을 가장많이 사용해왔다. (@Configuration 자바 코드를 참조하는 방식 대신 XML을 이용하는 경우 setter를 통해 DI하는 방법이 가장 편리하다.)

 1-8 XML을 이용한 설정
 ---------------------------------------------------------------------------
 
 DaoFactory는 DI 동작원리를 잘 활용한 독립적인 오브젝트 팩토리 클래스로 시작했지만 DI 컨테이너인 스프링을 도입하고 나서는 어노테이션을 추가해서 DI작업에 참고하는 일종의 참고정보로 사용되고 있다. 오브젝트 사이의 의존정보를 일일이 자바 코드로 만들어주려면 비슷한 구조가 반복되고 변경될 때 마다 다시 컴파일하기 번거롭다.
 => 스프링은 자바 설정파일을 이용하는 것 외에도 다양한 방법을 통해 DI 의존관계 설정정보를 만들 수 있다.
 => 대표적인 것이 XML
 
 XML 의 장점
 * 단순한 텍스트 파일이기 때문에 다루기 쉽다
 * 컴파일과 같은 별도의 빌드 작업이 없다.
 * 환경이 달라져서 오브젝트 관계가 바뀌는 경우에도 빠르게 변경사항 확인할 수 있다.
 
 
 스프링 어플리케이션 컨텍스트는 XML에 담긴 DI 정보를 활용할 수 있다.
 * @Configuration = \<beans>
 * @Bean = \<bean>
 
 
@Bean 메소드를 통해 얻을 수 있는 빈의 DI 정보는 다음 세 가지다.
 * 빈의 이름: @Bean 메소드 이름이 빈의 이름이다. => id
 * 빈의 클래스: @Bean 메소드에서 오브젝트를 만들 때 사용하는 클래스 이름(메소드의 리턴타입이 아님) => class
 * 빈의 의존 오브젝트: 빈의 생성자나 setter를 통해 의존오브젝트를 넣어준다. => \<property name=setter이름, ref=어트리뷰트를 주입할 오브젝트의 빈 id >
 
 XML 설정정보를 활용하도록 하려면 AnnotationConfigApplicationContext 대신 GenericXmlApplicationContext를 이용하여 다음과 같이 사용한다.=> ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml")
 
 XML property 태그의 value 어트리뷰트를 통해서 값을 주입할 수 있다.
 value 어트리뷰트에 스트링 값 뿐만 아니라 클래스 타입을 넣어도 되는데,스프링이 프로터티 값을 setter의 파라미터 타입을 참고해서 적절한 형태로 변환하기 때문이다.
 스프링은 value에 지정한 텍스트 값을 적절한 자바 타입으로 변환해준다. (Integer, Double, String, Boolean, Class, URL, File, Charset 등등..  값이 여러개 일때도 List, Map, Set, Properties, Array 타입으로도 값의 주입이 가능하다.)
 
  1-9 정리
  ---------------------------------------------------------------------------
 * 책임이 다른 코드를 분리해서 두개의 클래스로 만들었다 => 리펙토링
 * 변할 수 있는 클래스는 인터페이스를 구현하도록 하고, 다른 클래스에서 인터페이스를 통해서만 접근하도록 만들었다. 그 결과, 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 바뀌더라도 그 기능을 사용하는 클래스의 코드는 변경할 필요가 없게 만들었다 => 전략 패턴
 * 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막아주고 자신이 사용하는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경할 수 있게 했다 => 개방 폐쇠 원칙
 * 한쪽 기능의 변화가 다른쪽의 변경을 요구하지 않아도 되게 했고, 자신의 책임과 관심사에만 순수하게 집중하는 코드를 만들수 있었다 => 낮은 결합도와 높은 응집도
 * 오브젝트가 생성되고 다른 오브젝트와 관계를 맺는 작업의 제어권을 별도의 팩토리를 만들어서 책임을 넘겼다. 또는 팩토리의 기능을 일반화한 IoC 컨테이너로 넘겨서 오브젝트가 자신이 사용할 대상의 생성이나 선택에 대한 책임으로 부터 자유롭게 만들어줬다 => IoC
 * 싱글톤 패턴 구현 방식의 단점을 살펴보고 서버에서 사용되는 서비스 오브젝트로서의 장점을 살릴 수 있는 싱글톤의 장점을 사용하면서도, 싱글톤의 단점을 극복할 수 있도록 설계된 컨테이너를 활용하는 방법에 대해 알아보았다 => 싱글톤 레지스트리
 * 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어 놓고, 런타임 시에 실제 사용할 구체적인 오브젝트를 제3자를 통해 주입받아 의존관계를 갖게 해주는 IoC의 특별한 케이스를 알아보았다 => DI
 * 의존 오브젝트를 주입할 때 생성자를 이용하는 방법과 setter를 이용하는 방법을 알아보았다 => 생성자와 setter를 이용한 DI
 * XML을 이용해 DI 설정정보를 만드는 방법과 의존 오브젝트가 아닌 일반값을 외부에서 설정하여 런타임에 주입하는 방법을 알아보았다 => XML을 사용한 설정정보
 
 스프링이란 어떻게 오브젝느가 설계되고 만들어지고 관계를 맺고 사용되는지에 관심을 갖는 프레임워크 이다.
 
 